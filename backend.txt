def sheet_Growth_rate_in_Percentage(ctx: Mapping[str, pd.DataFrame]) -> pd.DataFrame:
    """
    Build the "Growth_rate (in Percentage)" sheet.

    Inputs expected in ctx:
      - "growth_rate": DataFrame loaded from folder 'growth_rate', filename keyword 'Growth', sheet_name 'CPI_A'.

    Logic:
      1) Find cell containing "Return To Index" (case-insensitive substring) -> (RN1, CN1).
      2) On row RN1, find year columns from 1990 onward (cells that parse to 4-digit year >= 1990).
      3) On column CN1, find the row that equals "United Arab Emirates" (case-insensitive). That's the value row.
      4) For each year column, read value at (value_row, year_col). Parse to float; if it's "x%" keep x as number (not divided).
      5) Output one-row DataFrame with columns: entity (renamed per helper), then years ascending.
    """
    import numpy as np
    import pandas as pd

    df = ctx["growth_rate"]
    # prepare string view for matching
    df_str = df.copy().applymap(lambda x: str(x).strip() if pd.notna(x) else "")

    # 1) locate "Return To Index"
    matches = np.argwhere(np.vectorize(lambda x: "return to index" in x.lower())(df_str.values))
    if matches.size == 0:
        raise ValueError("Could not find 'Return To Index' in growth_rate sheet")
    RN1, CN1 = matches[0].tolist()

    # 2) detect year columns on RN1
    years_map: dict[int, int] = {}  # col_index -> year_int
    row_vals = df_str.iloc[RN1, :].tolist()
    for j, txt in enumerate(row_vals):
        # allow forms like '1990', '1990 ', "1990.0"
        try:
            year = int(float(txt))
        except Exception:
            continue
        if 1990 <= year <= 2100 and len(str(int(year))) == 4:
            years_map[j] = int(year)
    if not years_map:
        raise ValueError("No year columns (>=1990) found on the RN1 row")

    # 3) find value row for United Arab Emirates in CN1
    col_series = df_str.iloc[:, CN1]
    uae_matches = col_series[col_series.str.lower() == "united arab emirates"].index.tolist()
    if not uae_matches:
        # try substring containment as a fallback
        uae_matches = col_series[col_series.str.lower().str.contains("united arab emirates")].index.tolist()
    if not uae_matches:
        raise ValueError("Could not locate 'United Arab Emirates' in the CN1 column")
    value_row = uae_matches[0]

    # 4) extract values for each year col
    def parse_percentish(x) -> float:
        if pd.isna(x):
            return 0.0
        s = str(x).strip()
        if s == "":
            return 0.0
        # if looks like '3.2%' -> 3.2 (keep percentage, not decimal)
        if s.endswith("%"):
            try:
                return float(s[:-1].strip())
            except Exception:
                return 0.0
        # else attempt float directly
        try:
            return float(s)
        except Exception:
            return 0.0

    # helper mapping for output entity name
    helper_config = {'growth_rate': {'United Arab Emirates': '5300_1GRT - HSBC Bank Middle East'}}
    entity_output = helper_config['growth_rate']['United Arab Emirates']

    # gather results sorted by year
    year_cols_sorted = sorted(years_map.items(), key=lambda kv: kv[1])  # (col, year)
    data = {"entity": [entity_output]}
    for col_idx, year in year_cols_sorted:
        val = parse_percentish(df.iloc[value_row, col_idx])
        data[year] = [val]

    # produce DataFrame with 'entity' then ascending years
    columns = ["entity"] + [y for _, y in year_cols_sorted]
    return pd.DataFrame(data)[columns]
