# frontend.py
import os
import sys
import shutil
import tempfile
import threading
from pathlib import Path
import tkinter as tk
from tkinter import ttk, filedialog, messagebox

from utility import PipelineConfig, InputSpec
from backend import run_pipeline

# ------------------------------
# Plug in YOUR real pipeline here
# ------------------------------
# Example placeholders (replace with your project’s real inputs/sheets):
INPUT_SPECS = [
    # InputSpec(logical_name="user_input", subfolder="user_input", keyword="user_input", sheet_name="user_input"),
    # InputSpec(logical_name="discount_rate", subfolder="discount_rate", keyword="CoE rates"),
    # ...
]
SHEET_FUNCS = {
    # "Discount_rate": sheet_discount_rate,
    # "Growth_rate (in Percentage)": sheet_Growth_rate_in_Percentage,
    # ...
}


class HBMEApp(tk.Tk):
    def __init__(self, inputs, sheet_funcs):
        super().__init__()
        self.title("HBME Input Automation")
        self.geometry("820x540")
        self.minsize(760, 520)
        self.configure(bg="#ffffff")

        # Data/state
        self.inputs = inputs
        self.sheet_funcs = dict(sheet_funcs)
        self.master_folder = ""
        self.temp_output = None
        self.saved_output = None

        # UI vars
        self.master_var = tk.StringVar(value="")
        self.helper_msg = tk.StringVar(value="Select Input Folder to begin")
        self.progress_var = tk.IntVar(value=0)
        self.progress_text = tk.StringVar(value="")
        self.output_path = tk.StringVar(value="")

        self._build_ui()
        self._set_stage_initial()

    # ---------------- UI layout ----------------
    def _build_ui(self):
        # Title
        tk.Label(
            self, text="HBME Input Automation",
            font=("Segoe UI", 22, "bold"), bg="#ffffff", fg="#1f1f1f"
        ).pack(pady=(18, 10))

        # Main body
        self.body = tk.Frame(self, bg="#ffffff")
        self.body.pack(fill="both", expand=True)

        # --- Input section (always visible) ---
        input_frame = tk.Frame(self.body, bg="#ffffff")
        input_frame.pack(fill="x", pady=(12, 4))

        # “Select Input Folder” label
        tk.Label(
            input_frame, text="Select Input Folder", font=("Segoe UI", 11),
            bg="#ffffff", fg="#333333"
        ).pack(anchor="center", pady=(0, 6))

        # entry + browse, centered
        row = tk.Frame(input_frame, bg="#ffffff")
        row.pack(anchor="center")
        self.entry = ttk.Entry(row, textvariable=self.master_var, width=78, state="readonly")
        self.entry.pack(side="left", padx=(0, 10))
        ttk.Button(row, text="Browse", command=self._browse_master).pack(side="left")

        # helper message / selected path (single line)
        tk.Label(
            input_frame, textvariable=self.helper_msg, font=("Segoe UI", 10),
            bg="#ffffff", fg="#666666"
        ).pack(anchor="center", pady=(8, 4))

        # --- Dynamic center stack (staged visibility) ---
        self.center_stack = tk.Frame(self.body, bg="#ffffff")
        self.center_stack.pack(fill="x", pady=(12, 0))

        # Run button (hidden initially)
        self.run_btn = tk.Button(
            self.center_stack, text="Run Input Population",
            font=("Segoe UI", 12, "bold"),
            bg="#f0c54a", fg="#222",
            activebackground="#e6b73a", relief="flat",
            padx=18, pady=8, command=self._run_clicked
        )

        # Progress bar (hidden initially)
        self.progress = ttk.Progressbar(self.center_stack, length=520, mode="determinate", variable=self.progress_var)

        # Live status (hidden initially)
        self.progress_label = tk.Label(
            self.center_stack, textvariable=self.progress_text,
            font=("Segoe UI", 10), bg="#ffffff", fg="#333333"
        )

        # Download button (hidden until finished)
        self.download_btn = tk.Button(
            self.center_stack, text="Download Input Template",
            font=("Segoe UI", 11),
            bg="#f0c54a", fg="#222",
            activebackground="#e6b73a", relief="flat",
            padx=14, pady=6, command=self._download_output
        )

        # Output path label (hidden until finished)
        self.output_lbl = tk.Label(
            self.center_stack, textvariable=self.output_path,
            font=("Segoe UI", 9), bg="#ffffff", fg="#555555", wraplength=720, justify="center"
        )

        # style tweak
        style = ttk.Style(self)
        style.theme_use("default")
        style.configure("TProgressbar", thickness=14)

    # ---------------- Stage controls ----------------
    def _set_stage_initial(self):
        # Only input section visible; everything else hidden
        self._hide_run()
        self._hide_progress()
        self._hide_download_and_output()

    def _set_stage_ready(self):
        # After folder chosen: show Run button centered
        self._show_run()
        self._hide_progress()
        self._hide_download_and_output()

    def _set_stage_running(self):
        # Show progress bar + live status; keep centered
        self._hide_download_and_output()
        self._show_progress()

    def _set_stage_finished(self):
        # Show Download button + output path; hide progress
        self._hide_progress()
        self._show_download_and_output()

    # show/hide helpers
    def _show_run(self):
        self.run_btn.pack_forget()
        self.run_btn.pack(anchor="center", pady=(6, 10))

    def _hide_run(self):
        self.run_btn.pack_forget()

    def _show_progress(self):
        self.progress.pack_forget()
        self.progress_label.pack_forget()
        self.progress.pack(anchor="center", pady=(10, 6))
        self.progress_label.pack(anchor="center", pady=(0, 6))

    def _hide_progress(self):
        self.progress.pack_forget()
        self.progress_label.pack_forget()

    def _show_download_and_output(self):
        self.download_btn.pack_forget()
        self.output_lbl.pack_forget()
        self.download_btn.pack(anchor="center", pady=(8, 4))
        self.output_lbl.pack(anchor="center", pady=(6, 8))

    def _hide_download_and_output(self):
        self.download_btn.pack_forget()
        self.output_lbl.pack_forget()

    # ---------------- Actions ----------------
    def _browse_master(self):
        folder = filedialog.askdirectory(title="Select Input (Master) Folder")
        if folder:
            self.master_folder = folder
            self.master_var.set(folder)
            self.helper_msg.set(folder)
            self._set_stage_ready()

    def _run_clicked(self):
        if not self.master_folder:
            messagebox.showwarning("Missing folder", "Please select the input (master) folder first.")
            return
        if not self.sheet_funcs:
            messagebox.showwarning("No sheets", "No sheet functions are configured.")
            return

        # Reset progress UI
        self.progress_var.set(0)
        self.progress_text.set("Starting…")
        self.output_path.set("")
        self._set_stage_running()
        self.run_btn.config(state="disabled")

        threading.Thread(target=self._do_run, daemon=True).start()

    def _wrap_sheet_funcs_for_progress(self, sheet_funcs):
        """Wrap sheet funcs to update the progress bar as each finishes."""
        total = len(sheet_funcs)
        count = {"done": 0}

        def make_wrapper(name, func):
            def wrapped(ctx):
                # announce start
                self._report(f"Populating '{name}'…")
                res = func(ctx)
                # update progress
                count["done"] += 1
                pct = int((count["done"] / total) * 100)
                self._set_progress(pct, f"{count['done']}/{total} completed ({pct}%)")
                return res
            return wrapped

        return {n: make_wrapper(n, f) for n, f in sheet_funcs.items()}

    def _do_run(self):
        tmp_dir = None
        try:
            cfg = PipelineConfig(master_folder=self.master_folder)
            wrapped_funcs = self._wrap_sheet_funcs_for_progress(self.sheet_funcs)

            # temp file first
            tmp_dir = tempfile.mkdtemp(prefix="hbme_")
            self.temp_output = str(Path(tmp_dir) / "HBME_input_template.xlsx")

            run_pipeline(
                cfg=cfg,
                inputs=INPUT_SPECS,
                sheet_funcs=wrapped_funcs,
                output_path=self.temp_output,
                password_provider=self._password_provider_modal,
                report=self._report,
            )

            self._report("Population completed.")
            # ask where to save
            self._prompt_save_output()

        except Exception as e:
            self._report(f"ERROR: {e}")
            messagebox.showerror("Error", str(e))
        finally:
            self.run_btn.config(state="normal")

    # ---------------- Save & Download ----------------
    def _prompt_save_output(self):
        suggested = "HBME_input_template.xlsx"
        save_path = filedialog.asksaveasfilename(
            title="Save Output Excel",
            defaultextension=".xlsx",
            initialfile=suggested,
            filetypes=[("Excel files", "*.xlsx")],
        )

        if not save_path:
            # user canceled — keep temp location
            self.output_path.set(f"Output created at temporary path:\n{self.temp_output}")
            self._set_stage_finished()
            return

        try:
            shutil.copyfile(self.temp_output, save_path)
            self.saved_output = save_path
            self.output_path.set(f"Output saved to:\n{save_path}")
            self._set_stage_finished()
            messagebox.showinfo("Success", f"Output saved to:\n{save_path}")
        except Exception as e:
            messagebox.showerror("Save failed", str(e))
            self.output_path.set(f"Temporary output at:\n{self.temp_output}")
            self._set_stage_finished()

    def _download_output(self):
        target = self.saved_output or self.temp_output
        if not target or not os.path.exists(target):
            messagebox.showwarning("File missing", "No output file is available yet.")
            return
        try:
            if sys.platform.startswith("win"):
                os.startfile(target)  # type: ignore[attr-defined]
            elif sys.platform == "darwin":
                os.system(f'open "{target}"')
            else:
                os.system(f'xdg-open "{target}"')
        except Exception as e:
            messagebox.showerror("Open failed", str(e))

    # ---------------- Progress / report ----------------
    def _set_progress(self, value, text=None):
        self.progress_var.set(max(0, min(100, int(value))))
        if text is not None:
            self.progress_text.set(text)
        self.update_idletasks()

    def _report(self, msg: str):
        self.progress_text.set(msg)
        self.update_idletasks()

    # ---------------- Password modal ----------------
    def _password_provider_modal(self, filename: str) -> str:
        dlg = tk.Toplevel(self)
        dlg.title("Password required")
        dlg.configure(bg="#ffffff")
        dlg.resizable(False, False)

        tk.Label(
            dlg, text=f"Enter password for:\n{filename}",
            font=("Segoe UI", 10), bg="#ffffff", fg="#333333", justify="left"
        ).pack(padx=16, pady=(14, 8))

        var = tk.StringVar()
        entry = ttk.Entry(dlg, textvariable=var, show="*")
        entry.pack(padx=16, pady=(0, 12), fill="x")
        entry.focus_set()

        out = {"pw": ""}

        def submit():
            out["pw"] = var.get().strip()
            dlg.destroy()

        ttk.Button(dlg, text="Submit", command=submit).pack(pady=(0, 14))
        dlg.transient(self)
        dlg.grab_set()
        self.wait_window(dlg)

        if not out["pw"]:
            messagebox.showwarning("Password", "Empty password provided. You may be prompted again.")
        return out["pw"] or ""


if __name__ == "__main__":
    # Replace INPUT_SPECS and SHEET_FUNCS with your real pipeline above.
    HBMEApp(inputs=INPUT_SPECS, sheet_funcs=SHEET_FUNCS).mainloop()
